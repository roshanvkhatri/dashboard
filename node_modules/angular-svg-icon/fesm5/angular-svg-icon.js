import { Injectable, InjectionToken, Inject, PLATFORM_ID, Optional, SkipSelf, ElementRef, KeyValueDiffers, Renderer2, ChangeDetectorRef, Input, Component, NgModule } from '@angular/core';
import { DOCUMENT, CommonModule } from '@angular/common';
import { of, throwError } from 'rxjs';
import { map, tap, catchError, finalize, share } from 'rxjs/operators';
import { HttpClient } from '@angular/common/http';

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var SvgLoader = /** @class */ (function () {
    function SvgLoader() {
    }
    return SvgLoader;
}());
var SvgHttpLoader = /** @class */ (function (_super) {
    __extends(SvgHttpLoader, _super);
    function SvgHttpLoader(http) {
        var _this = _super.call(this) || this;
        _this.http = http;
        return _this;
    }
    SvgHttpLoader.prototype.getSvg = function (url) {
        return this.http.get(url, { responseType: 'text' });
    };
    SvgHttpLoader.ctorParameters = function () { return [
        { type: HttpClient }
    ]; };
    SvgHttpLoader = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [HttpClient])
    ], SvgHttpLoader);
    return SvgHttpLoader;
}(SvgLoader));

var __decorate$1 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$1 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var SERVER_URL = new InjectionToken('SERVER_URL');
var SvgIconRegistryService = /** @class */ (function () {
    function SvgIconRegistryService(loader, platformId, serverUrl, _document) {
        this.loader = loader;
        this.platformId = platformId;
        this.serverUrl = serverUrl;
        this._document = _document;
        this.iconsByUrl = new Map();
        this.iconsLoadingByUrl = new Map();
        this.document = this._document;
    }
    /** Add a SVG to the registry by passing a name and the SVG. */
    SvgIconRegistryService.prototype.addSvg = function (name, data) {
        if (!this.iconsByUrl.has(name)) {
            var div = this.document.createElement('DIV');
            div.innerHTML = data;
            var svg = div.querySelector('svg');
            this.iconsByUrl.set(name, svg);
        }
    };
    /** Load a SVG to the registry from a URL. */
    SvgIconRegistryService.prototype.loadSvg = function (url, name) {
        var _this = this;
        if (name === void 0) { name = url; }
        // not sure if there should be a possibility to use name for server usage
        // so overriding it for now if provided
        // maybe should separate functionality for url and name use-cases
        if (this.serverUrl && url.match(/^(http(s)?):/) === null) {
            url = this.serverUrl + url;
            name = url;
        }
        if (this.iconsByUrl.has(name)) {
            return of(this.iconsByUrl.get(name));
        }
        else if (this.iconsLoadingByUrl.has(name)) {
            return this.iconsLoadingByUrl.get(name);
        }
        var o = this.loader.getSvg(url).pipe(map(function (svg) {
            var div = _this.document.createElement('DIV');
            div.innerHTML = svg;
            return div.querySelector('svg');
        }), tap(function (svg) { return _this.iconsByUrl.set(name, svg); }), catchError(function (err) {
            console.error(err);
            return throwError(err);
        }), finalize(function () { return _this.iconsLoadingByUrl.delete(name); }), share());
        this.iconsLoadingByUrl.set(name, o);
        return o;
    };
    /** Get loaded SVG from registry by name. (also works by url because of blended map) */
    SvgIconRegistryService.prototype.getSvgByName = function (name) {
        if (this.iconsByUrl.has(name)) {
            return of(this.iconsByUrl.get(name));
        }
        else if (this.iconsLoadingByUrl.has(name)) {
            return this.iconsLoadingByUrl.get(name);
        }
        return throwError("No svg with name '" + name + "' has been loaded");
    };
    /** Remove a SVG from the registry by URL (or name). */
    SvgIconRegistryService.prototype.unloadSvg = function (url) {
        if (this.iconsByUrl.has(url)) {
            this.iconsByUrl.delete(url);
        }
    };
    SvgIconRegistryService.ctorParameters = function () { return [
        { type: SvgLoader },
        { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
        { type: String, decorators: [{ type: Optional }, { type: Inject, args: [SERVER_URL,] }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
    ]; };
    SvgIconRegistryService = __decorate$1([
        Injectable(),
        __param(1, Inject(PLATFORM_ID)),
        __param(2, Optional()), __param(2, Inject(SERVER_URL)),
        __param(3, Optional()), __param(3, Inject(DOCUMENT)),
        __metadata$1("design:paramtypes", [SvgLoader,
            Object, String, Object])
    ], SvgIconRegistryService);
    return SvgIconRegistryService;
}());
function SVG_ICON_REGISTRY_PROVIDER_FACTORY(parentRegistry, loader, platformId, serverUrl, document) {
    return parentRegistry || new SvgIconRegistryService(loader, platformId, serverUrl, document);
}
var SVG_ICON_REGISTRY_PROVIDER = {
    provide: SvgIconRegistryService,
    deps: [[new Optional(), new SkipSelf(), SvgIconRegistryService], SvgLoader, [PLATFORM_ID],
        [new Optional(), SERVER_URL], [new Optional(), DOCUMENT]
    ],
    useFactory: SVG_ICON_REGISTRY_PROVIDER_FACTORY
};

var __decorate$2 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$2 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var SvgIconComponent = /** @class */ (function () {
    function SvgIconComponent(element, differs, renderer, iconReg, cdr) {
        this.element = element;
        this.differs = differs;
        this.renderer = renderer;
        this.iconReg = iconReg;
        this.cdr = cdr;
        this.stretch = false;
        this.applyClass = false;
        /** @deprecated since 9.1.0 */
        this.applyCss = false;
        this.loaded = false;
    }
    Object.defineProperty(SvgIconComponent.prototype, "svgStyle", {
        // Adapted from ngStyle
        set: function (v) {
            this._svgStyle = v;
            if (!this.differ && v) {
                this.differ = this.differs.find(v).create();
            }
        },
        enumerable: true,
        configurable: true
    });
    SvgIconComponent.prototype.ngOnInit = function () {
        this.init();
    };
    SvgIconComponent.prototype.ngOnDestroy = function () {
        this.destroy();
    };
    SvgIconComponent.prototype.ngOnChanges = function (changeRecord) {
        if (changeRecord.src || changeRecord.name) {
            if (this.loaded) {
                this.destroy();
            }
            this.init();
        }
        if (changeRecord.stretch) {
            this.stylize();
        }
        if (changeRecord.applyClass) {
            if (this.applyClass) {
                this.setClass(null, this.klass);
            }
            else {
                this.setClass(this.klass, null);
            }
        }
        if (changeRecord.svgClass) {
            this.setClass(changeRecord.svgClass.previousValue, changeRecord.svgClass.currentValue);
        }
        if (changeRecord.klass) {
            if (this.applyClass) {
                this.setClass(changeRecord.klass.previousValue, changeRecord.klass.currentValue);
            }
            else {
                this.setClass(changeRecord.klass.previousValue, null);
            }
        }
        if (changeRecord.viewBox) {
            if (this.loaded) {
                this.destroy();
            }
            this.init();
        }
        if (changeRecord.applyCss) {
            console.warn('applyCss deprecated since 9.1.0, will be removed in 10.0.0');
            console.warn('use applyClass instead');
        }
    };
    SvgIconComponent.prototype.ngDoCheck = function () {
        if (this.svg && this.differ) {
            var changes = this.differ.diff(this._svgStyle);
            if (changes) {
                this.applyChanges(changes);
            }
        }
    };
    SvgIconComponent.prototype.init = function () {
        if (this.name) {
            this.icnSub = this.iconReg.getSvgByName(this.name).subscribe(this.initSvg.bind(this));
        }
        else if (this.src) {
            this.icnSub = this.iconReg.loadSvg(this.src).subscribe(this.initSvg.bind(this));
        }
        else {
            var elem = this.element.nativeElement;
            elem.innerHTML = '';
            this.cdr.markForCheck();
        }
    };
    SvgIconComponent.prototype.initSvg = function (svg) {
        if (!this.loaded) {
            this.setSvg(svg);
            this.resetDiffer();
        }
    };
    SvgIconComponent.prototype.destroy = function () {
        this.svg = undefined;
        this.differ = undefined;
        this.loaded = false;
        if (this.icnSub) {
            this.icnSub.unsubscribe();
        }
    };
    SvgIconComponent.prototype.resetDiffer = function () {
        if (this._svgStyle && !this.differ) {
            this.differ = this.differs.find(this._svgStyle).create();
        }
    };
    SvgIconComponent.prototype.setSvg = function (svg) {
        if (!this.loaded && svg) {
            this.svg = svg;
            var icon = svg.cloneNode(true);
            var elem = this.element.nativeElement;
            this.copyNgContentAttribute(elem, icon);
            if (this.klass && this.applyClass) {
                this.renderer.setAttribute(icon, 'class', this.klass);
            }
            if (this.svgClass) {
                this.renderer.setAttribute(icon, 'class', this.svgClass);
            }
            if (this.viewBox) {
                if (this.viewBox === 'auto') {
                    // Attempt to convert height & width to a viewBox.
                    var w = icon.getAttribute('width');
                    var h = icon.getAttribute('height');
                    if (h && w) {
                        var vb = "0 0 " + w + " " + h;
                        this.renderer.setAttribute(icon, 'viewBox', vb);
                        this.renderer.removeAttribute(icon, 'width');
                        this.renderer.removeAttribute(icon, 'height');
                    }
                }
                else if (this.viewBox !== '') {
                    this.renderer.setAttribute(icon, 'viewBox', this.viewBox);
                    this.renderer.removeAttribute(icon, 'width');
                    this.renderer.removeAttribute(icon, 'height');
                }
            }
            elem.innerHTML = '';
            this.renderer.appendChild(elem, icon);
            this.loaded = true;
            this.stylize();
            this.cdr.markForCheck();
        }
    };
    SvgIconComponent.prototype.copyNgContentAttribute = function (hostElem, icon) {
        var attributes = hostElem.attributes;
        var len = attributes.length;
        for (var i = 0; i < len; i += 1) {
            var attribute = attributes.item(i);
            if (attribute.name.startsWith('_ngcontent')) {
                this.setNgContentAttribute(icon, attribute.name);
                break;
            }
        }
    };
    SvgIconComponent.prototype.setNgContentAttribute = function (parent, attributeName) {
        this.renderer.setAttribute(parent, attributeName, '');
        var len = parent.childNodes.length;
        for (var i = 0; i < len; i += 1) {
            var child = parent.childNodes[i];
            if (child instanceof Element) {
                this.setNgContentAttribute(child, attributeName);
            }
        }
    };
    SvgIconComponent.prototype.stylize = function () {
        if (this.svg) {
            var svg = this.element.nativeElement.firstChild;
            if (this.stretch === true) {
                this.renderer.setAttribute(svg, 'preserveAspectRatio', 'none');
            }
            else if (this.stretch === false) {
                this.renderer.removeAttribute(svg, 'preserveAspectRatio');
            }
        }
    };
    SvgIconComponent.prototype.applyChanges = function (changes) {
        var _this = this;
        changes.forEachRemovedItem(function (record) { return _this.setStyle(record.key, null); });
        changes.forEachAddedItem(function (record) { return _this.setStyle(record.key, record.currentValue); });
        changes.forEachChangedItem(function (record) { return _this.setStyle(record.key, record.currentValue); });
    };
    SvgIconComponent.prototype.setStyle = function (nameAndUnit, value) {
        var _a = __read(nameAndUnit.split('.'), 2), name = _a[0], unit = _a[1];
        value = value !== null && unit ? "" + value + unit : value;
        var svg = this.element.nativeElement.firstChild;
        if (value !== null) {
            this.renderer.setStyle(svg, name, value);
        }
        else {
            this.renderer.removeStyle(svg, name);
        }
    };
    SvgIconComponent.prototype.setClass = function (previous, current) {
        var e_1, _a;
        var svg = this.element.nativeElement.firstChild;
        if (svg) {
            if (previous) {
                this.renderer.removeClass(svg, previous);
            }
            if (current) {
                var klasses = current.split(' ');
                try {
                    for (var klasses_1 = __values(klasses), klasses_1_1 = klasses_1.next(); !klasses_1_1.done; klasses_1_1 = klasses_1.next()) {
                        var k = klasses_1_1.value;
                        this.renderer.addClass(svg, k);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (klasses_1_1 && !klasses_1_1.done && (_a = klasses_1.return)) _a.call(klasses_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        }
    };
    SvgIconComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: KeyValueDiffers },
        { type: Renderer2 },
        { type: SvgIconRegistryService },
        { type: ChangeDetectorRef }
    ]; };
    __decorate$2([
        Input(),
        __metadata$2("design:type", String)
    ], SvgIconComponent.prototype, "src", void 0);
    __decorate$2([
        Input(),
        __metadata$2("design:type", String)
    ], SvgIconComponent.prototype, "name", void 0);
    __decorate$2([
        Input(),
        __metadata$2("design:type", Object)
    ], SvgIconComponent.prototype, "stretch", void 0);
    __decorate$2([
        Input(),
        __metadata$2("design:type", Object)
    ], SvgIconComponent.prototype, "applyClass", void 0);
    __decorate$2([
        Input(),
        __metadata$2("design:type", Object)
    ], SvgIconComponent.prototype, "applyCss", void 0);
    __decorate$2([
        Input(),
        __metadata$2("design:type", String)
    ], SvgIconComponent.prototype, "svgClass", void 0);
    __decorate$2([
        Input('class'),
        __metadata$2("design:type", String)
    ], SvgIconComponent.prototype, "klass", void 0);
    __decorate$2([
        Input(),
        __metadata$2("design:type", String)
    ], SvgIconComponent.prototype, "viewBox", void 0);
    __decorate$2([
        Input(),
        __metadata$2("design:type", Object),
        __metadata$2("design:paramtypes", [Object])
    ], SvgIconComponent.prototype, "svgStyle", null);
    SvgIconComponent = __decorate$2([
        Component({
            selector: 'svg-icon',
            template: '<ng-content></ng-content>'
        }),
        __metadata$2("design:paramtypes", [ElementRef,
            KeyValueDiffers,
            Renderer2,
            SvgIconRegistryService,
            ChangeDetectorRef])
    ], SvgIconComponent);
    return SvgIconComponent;
}());

var __decorate$3 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AngularSvgIconModule = /** @class */ (function () {
    function AngularSvgIconModule() {
    }
    AngularSvgIconModule_1 = AngularSvgIconModule;
    AngularSvgIconModule.forRoot = function (config) {
        if (config === void 0) { config = {}; }
        return {
            ngModule: AngularSvgIconModule_1,
            providers: [
                SVG_ICON_REGISTRY_PROVIDER,
                config.loader || { provide: SvgLoader, useClass: SvgHttpLoader }
            ]
        };
    };
    var AngularSvgIconModule_1;
    AngularSvgIconModule = AngularSvgIconModule_1 = __decorate$3([
        NgModule({
            imports: [
                CommonModule,
            ],
            declarations: [
                SvgIconComponent
            ],
            exports: [SvgIconComponent]
        })
    ], AngularSvgIconModule);
    return AngularSvgIconModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { AngularSvgIconModule, SERVER_URL, SVG_ICON_REGISTRY_PROVIDER, SVG_ICON_REGISTRY_PROVIDER_FACTORY, SvgHttpLoader, SvgIconComponent, SvgIconRegistryService, SvgLoader };
//# sourceMappingURL=angular-svg-icon.js.map
