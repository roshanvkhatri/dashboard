(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('rxjs'), require('rxjs/operators'), require('@angular/common/http')) :
    typeof define === 'function' && define.amd ? define('angular-svg-icon', ['exports', '@angular/core', '@angular/common', 'rxjs', 'rxjs/operators', '@angular/common/http'], factory) :
    (global = global || self, factory(global['angular-svg-icon'] = {}, global.ng.core, global.ng.common, global.rxjs, global.rxjs.operators, global.ng.common.http));
}(this, (function (exports, core, common, rxjs, operators, http) { 'use strict';

    var __extends = (this && this.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = (this && this.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var SvgLoader = /** @class */ (function () {
        function SvgLoader() {
        }
        return SvgLoader;
    }());
    var SvgHttpLoader = /** @class */ (function (_super) {
        __extends(SvgHttpLoader, _super);
        function SvgHttpLoader(http) {
            var _this = _super.call(this) || this;
            _this.http = http;
            return _this;
        }
        SvgHttpLoader.prototype.getSvg = function (url) {
            return this.http.get(url, { responseType: 'text' });
        };
        SvgHttpLoader.ctorParameters = function () { return [
            { type: http.HttpClient }
        ]; };
        SvgHttpLoader = __decorate([
            core.Injectable(),
            __metadata("design:paramtypes", [http.HttpClient])
        ], SvgHttpLoader);
        return SvgHttpLoader;
    }(SvgLoader));

    var __decorate$1 = (this && this.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$1 = (this && this.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var __param = (this && this.__param) || function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };
    var SERVER_URL = new core.InjectionToken('SERVER_URL');
    var SvgIconRegistryService = /** @class */ (function () {
        function SvgIconRegistryService(loader, platformId, serverUrl, _document) {
            this.loader = loader;
            this.platformId = platformId;
            this.serverUrl = serverUrl;
            this._document = _document;
            this.iconsByUrl = new Map();
            this.iconsLoadingByUrl = new Map();
            this.document = this._document;
        }
        /** Add a SVG to the registry by passing a name and the SVG. */
        SvgIconRegistryService.prototype.addSvg = function (name, data) {
            if (!this.iconsByUrl.has(name)) {
                var div = this.document.createElement('DIV');
                div.innerHTML = data;
                var svg = div.querySelector('svg');
                this.iconsByUrl.set(name, svg);
            }
        };
        /** Load a SVG to the registry from a URL. */
        SvgIconRegistryService.prototype.loadSvg = function (url, name) {
            var _this = this;
            if (name === void 0) { name = url; }
            // not sure if there should be a possibility to use name for server usage
            // so overriding it for now if provided
            // maybe should separate functionality for url and name use-cases
            if (this.serverUrl && url.match(/^(http(s)?):/) === null) {
                url = this.serverUrl + url;
                name = url;
            }
            if (this.iconsByUrl.has(name)) {
                return rxjs.of(this.iconsByUrl.get(name));
            }
            else if (this.iconsLoadingByUrl.has(name)) {
                return this.iconsLoadingByUrl.get(name);
            }
            var o = this.loader.getSvg(url).pipe(operators.map(function (svg) {
                var div = _this.document.createElement('DIV');
                div.innerHTML = svg;
                return div.querySelector('svg');
            }), operators.tap(function (svg) { return _this.iconsByUrl.set(name, svg); }), operators.catchError(function (err) {
                console.error(err);
                return rxjs.throwError(err);
            }), operators.finalize(function () { return _this.iconsLoadingByUrl.delete(name); }), operators.share());
            this.iconsLoadingByUrl.set(name, o);
            return o;
        };
        /** Get loaded SVG from registry by name. (also works by url because of blended map) */
        SvgIconRegistryService.prototype.getSvgByName = function (name) {
            if (this.iconsByUrl.has(name)) {
                return rxjs.of(this.iconsByUrl.get(name));
            }
            else if (this.iconsLoadingByUrl.has(name)) {
                return this.iconsLoadingByUrl.get(name);
            }
            return rxjs.throwError("No svg with name '" + name + "' has been loaded");
        };
        /** Remove a SVG from the registry by URL (or name). */
        SvgIconRegistryService.prototype.unloadSvg = function (url) {
            if (this.iconsByUrl.has(url)) {
                this.iconsByUrl.delete(url);
            }
        };
        SvgIconRegistryService.ctorParameters = function () { return [
            { type: SvgLoader },
            { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] },
            { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [SERVER_URL,] }] },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] }
        ]; };
        SvgIconRegistryService = __decorate$1([
            core.Injectable(),
            __param(1, core.Inject(core.PLATFORM_ID)),
            __param(2, core.Optional()), __param(2, core.Inject(SERVER_URL)),
            __param(3, core.Optional()), __param(3, core.Inject(common.DOCUMENT)),
            __metadata$1("design:paramtypes", [SvgLoader,
                Object, String, Object])
        ], SvgIconRegistryService);
        return SvgIconRegistryService;
    }());
    function SVG_ICON_REGISTRY_PROVIDER_FACTORY(parentRegistry, loader, platformId, serverUrl, document) {
        return parentRegistry || new SvgIconRegistryService(loader, platformId, serverUrl, document);
    }
    var SVG_ICON_REGISTRY_PROVIDER = {
        provide: SvgIconRegistryService,
        deps: [[new core.Optional(), new core.SkipSelf(), SvgIconRegistryService], SvgLoader, [core.PLATFORM_ID],
            [new core.Optional(), SERVER_URL], [new core.Optional(), common.DOCUMENT]
        ],
        useFactory: SVG_ICON_REGISTRY_PROVIDER_FACTORY
    };

    var __decorate$2 = (this && this.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$2 = (this && this.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
    };
    var __read = (this && this.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __values = (this && this.__values) || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var SvgIconComponent = /** @class */ (function () {
        function SvgIconComponent(element, differs, renderer, iconReg, cdr) {
            this.element = element;
            this.differs = differs;
            this.renderer = renderer;
            this.iconReg = iconReg;
            this.cdr = cdr;
            this.stretch = false;
            this.applyClass = false;
            /** @deprecated since 9.1.0 */
            this.applyCss = false;
            this.loaded = false;
        }
        Object.defineProperty(SvgIconComponent.prototype, "svgStyle", {
            // Adapted from ngStyle
            set: function (v) {
                this._svgStyle = v;
                if (!this.differ && v) {
                    this.differ = this.differs.find(v).create();
                }
            },
            enumerable: true,
            configurable: true
        });
        SvgIconComponent.prototype.ngOnInit = function () {
            this.init();
        };
        SvgIconComponent.prototype.ngOnDestroy = function () {
            this.destroy();
        };
        SvgIconComponent.prototype.ngOnChanges = function (changeRecord) {
            if (changeRecord.src || changeRecord.name) {
                if (this.loaded) {
                    this.destroy();
                }
                this.init();
            }
            if (changeRecord.stretch) {
                this.stylize();
            }
            if (changeRecord.applyClass) {
                if (this.applyClass) {
                    this.setClass(null, this.klass);
                }
                else {
                    this.setClass(this.klass, null);
                }
            }
            if (changeRecord.svgClass) {
                this.setClass(changeRecord.svgClass.previousValue, changeRecord.svgClass.currentValue);
            }
            if (changeRecord.klass) {
                if (this.applyClass) {
                    this.setClass(changeRecord.klass.previousValue, changeRecord.klass.currentValue);
                }
                else {
                    this.setClass(changeRecord.klass.previousValue, null);
                }
            }
            if (changeRecord.viewBox) {
                if (this.loaded) {
                    this.destroy();
                }
                this.init();
            }
            if (changeRecord.applyCss) {
                console.warn('applyCss deprecated since 9.1.0, will be removed in 10.0.0');
                console.warn('use applyClass instead');
            }
        };
        SvgIconComponent.prototype.ngDoCheck = function () {
            if (this.svg && this.differ) {
                var changes = this.differ.diff(this._svgStyle);
                if (changes) {
                    this.applyChanges(changes);
                }
            }
        };
        SvgIconComponent.prototype.init = function () {
            if (this.name) {
                this.icnSub = this.iconReg.getSvgByName(this.name).subscribe(this.initSvg.bind(this));
            }
            else if (this.src) {
                this.icnSub = this.iconReg.loadSvg(this.src).subscribe(this.initSvg.bind(this));
            }
            else {
                var elem = this.element.nativeElement;
                elem.innerHTML = '';
                this.cdr.markForCheck();
            }
        };
        SvgIconComponent.prototype.initSvg = function (svg) {
            if (!this.loaded) {
                this.setSvg(svg);
                this.resetDiffer();
            }
        };
        SvgIconComponent.prototype.destroy = function () {
            this.svg = undefined;
            this.differ = undefined;
            this.loaded = false;
            if (this.icnSub) {
                this.icnSub.unsubscribe();
            }
        };
        SvgIconComponent.prototype.resetDiffer = function () {
            if (this._svgStyle && !this.differ) {
                this.differ = this.differs.find(this._svgStyle).create();
            }
        };
        SvgIconComponent.prototype.setSvg = function (svg) {
            if (!this.loaded && svg) {
                this.svg = svg;
                var icon = svg.cloneNode(true);
                var elem = this.element.nativeElement;
                this.copyNgContentAttribute(elem, icon);
                if (this.klass && this.applyClass) {
                    this.renderer.setAttribute(icon, 'class', this.klass);
                }
                if (this.svgClass) {
                    this.renderer.setAttribute(icon, 'class', this.svgClass);
                }
                if (this.viewBox) {
                    if (this.viewBox === 'auto') {
                        // Attempt to convert height & width to a viewBox.
                        var w = icon.getAttribute('width');
                        var h = icon.getAttribute('height');
                        if (h && w) {
                            var vb = "0 0 " + w + " " + h;
                            this.renderer.setAttribute(icon, 'viewBox', vb);
                            this.renderer.removeAttribute(icon, 'width');
                            this.renderer.removeAttribute(icon, 'height');
                        }
                    }
                    else if (this.viewBox !== '') {
                        this.renderer.setAttribute(icon, 'viewBox', this.viewBox);
                        this.renderer.removeAttribute(icon, 'width');
                        this.renderer.removeAttribute(icon, 'height');
                    }
                }
                elem.innerHTML = '';
                this.renderer.appendChild(elem, icon);
                this.loaded = true;
                this.stylize();
                this.cdr.markForCheck();
            }
        };
        SvgIconComponent.prototype.copyNgContentAttribute = function (hostElem, icon) {
            var attributes = hostElem.attributes;
            var len = attributes.length;
            for (var i = 0; i < len; i += 1) {
                var attribute = attributes.item(i);
                if (attribute.name.startsWith('_ngcontent')) {
                    this.setNgContentAttribute(icon, attribute.name);
                    break;
                }
            }
        };
        SvgIconComponent.prototype.setNgContentAttribute = function (parent, attributeName) {
            this.renderer.setAttribute(parent, attributeName, '');
            var len = parent.childNodes.length;
            for (var i = 0; i < len; i += 1) {
                var child = parent.childNodes[i];
                if (child instanceof Element) {
                    this.setNgContentAttribute(child, attributeName);
                }
            }
        };
        SvgIconComponent.prototype.stylize = function () {
            if (this.svg) {
                var svg = this.element.nativeElement.firstChild;
                if (this.stretch === true) {
                    this.renderer.setAttribute(svg, 'preserveAspectRatio', 'none');
                }
                else if (this.stretch === false) {
                    this.renderer.removeAttribute(svg, 'preserveAspectRatio');
                }
            }
        };
        SvgIconComponent.prototype.applyChanges = function (changes) {
            var _this = this;
            changes.forEachRemovedItem(function (record) { return _this.setStyle(record.key, null); });
            changes.forEachAddedItem(function (record) { return _this.setStyle(record.key, record.currentValue); });
            changes.forEachChangedItem(function (record) { return _this.setStyle(record.key, record.currentValue); });
        };
        SvgIconComponent.prototype.setStyle = function (nameAndUnit, value) {
            var _a = __read(nameAndUnit.split('.'), 2), name = _a[0], unit = _a[1];
            value = value !== null && unit ? "" + value + unit : value;
            var svg = this.element.nativeElement.firstChild;
            if (value !== null) {
                this.renderer.setStyle(svg, name, value);
            }
            else {
                this.renderer.removeStyle(svg, name);
            }
        };
        SvgIconComponent.prototype.setClass = function (previous, current) {
            var e_1, _a;
            var svg = this.element.nativeElement.firstChild;
            if (svg) {
                if (previous) {
                    this.renderer.removeClass(svg, previous);
                }
                if (current) {
                    var klasses = current.split(' ');
                    try {
                        for (var klasses_1 = __values(klasses), klasses_1_1 = klasses_1.next(); !klasses_1_1.done; klasses_1_1 = klasses_1.next()) {
                            var k = klasses_1_1.value;
                            this.renderer.addClass(svg, k);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (klasses_1_1 && !klasses_1_1.done && (_a = klasses_1.return)) _a.call(klasses_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
            }
        };
        SvgIconComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.KeyValueDiffers },
            { type: core.Renderer2 },
            { type: SvgIconRegistryService },
            { type: core.ChangeDetectorRef }
        ]; };
        __decorate$2([
            core.Input(),
            __metadata$2("design:type", String)
        ], SvgIconComponent.prototype, "src", void 0);
        __decorate$2([
            core.Input(),
            __metadata$2("design:type", String)
        ], SvgIconComponent.prototype, "name", void 0);
        __decorate$2([
            core.Input(),
            __metadata$2("design:type", Object)
        ], SvgIconComponent.prototype, "stretch", void 0);
        __decorate$2([
            core.Input(),
            __metadata$2("design:type", Object)
        ], SvgIconComponent.prototype, "applyClass", void 0);
        __decorate$2([
            core.Input(),
            __metadata$2("design:type", Object)
        ], SvgIconComponent.prototype, "applyCss", void 0);
        __decorate$2([
            core.Input(),
            __metadata$2("design:type", String)
        ], SvgIconComponent.prototype, "svgClass", void 0);
        __decorate$2([
            core.Input('class'),
            __metadata$2("design:type", String)
        ], SvgIconComponent.prototype, "klass", void 0);
        __decorate$2([
            core.Input(),
            __metadata$2("design:type", String)
        ], SvgIconComponent.prototype, "viewBox", void 0);
        __decorate$2([
            core.Input(),
            __metadata$2("design:type", Object),
            __metadata$2("design:paramtypes", [Object])
        ], SvgIconComponent.prototype, "svgStyle", null);
        SvgIconComponent = __decorate$2([
            core.Component({
                selector: 'svg-icon',
                template: '<ng-content></ng-content>'
            }),
            __metadata$2("design:paramtypes", [core.ElementRef,
                core.KeyValueDiffers,
                core.Renderer2,
                SvgIconRegistryService,
                core.ChangeDetectorRef])
        ], SvgIconComponent);
        return SvgIconComponent;
    }());

    var __decorate$3 = (this && this.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var AngularSvgIconModule = /** @class */ (function () {
        function AngularSvgIconModule() {
        }
        AngularSvgIconModule_1 = AngularSvgIconModule;
        AngularSvgIconModule.forRoot = function (config) {
            if (config === void 0) { config = {}; }
            return {
                ngModule: AngularSvgIconModule_1,
                providers: [
                    SVG_ICON_REGISTRY_PROVIDER,
                    config.loader || { provide: SvgLoader, useClass: SvgHttpLoader }
                ]
            };
        };
        var AngularSvgIconModule_1;
        AngularSvgIconModule = AngularSvgIconModule_1 = __decorate$3([
            core.NgModule({
                imports: [
                    common.CommonModule,
                ],
                declarations: [
                    SvgIconComponent
                ],
                exports: [SvgIconComponent]
            })
        ], AngularSvgIconModule);
        return AngularSvgIconModule;
    }());

    exports.AngularSvgIconModule = AngularSvgIconModule;
    exports.SERVER_URL = SERVER_URL;
    exports.SVG_ICON_REGISTRY_PROVIDER = SVG_ICON_REGISTRY_PROVIDER;
    exports.SVG_ICON_REGISTRY_PROVIDER_FACTORY = SVG_ICON_REGISTRY_PROVIDER_FACTORY;
    exports.SvgHttpLoader = SvgHttpLoader;
    exports.SvgIconComponent = SvgIconComponent;
    exports.SvgIconRegistryService = SvgIconRegistryService;
    exports.SvgLoader = SvgLoader;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=angular-svg-icon.umd.js.map
